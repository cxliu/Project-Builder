#!/usr/bin/env python

"""usage: %prog build_info_file id

This will attempt to compile a particular configuration of a project generated
by M-Build. The build_info_file should be the file generated by
create_build_info.py, and the id should correspond to one of the ids in the
build info file.
"""

import optparse
import os
import sys
import imp
import subprocess
import tempfile
import re
import shlex

BASE = os.path.join(os.path.dirname(__file__), '..', '..')
sys.path.append(os.path.join(BASE, 'mbuild'))

from src.util.which import which

class BuildError(Exception): pass

class MissingDependencyError(BuildError):
	"""Raised when we can't build a project because we don't have the tools
	installed to build it (this may be because the tools aren't available
	on this particular platform, or may be because the tools just haven't been
	installed).
	"""
	def __init__(self, tool_name, tool_file_name):
		self._tool_name = tool_name
		self._tool_file_name = tool_file_name

	def __str__(self):
		if self._tool_file_name is None:
			return "Mising build tool %r" % (self._tool_name)
		else:
			return "Mising build tool %r (%r)" % (self._tool_name, self._tool_file_name)
	
	def get_tool_name(self):
		return self._tool_name
	
	def get_tool_file_name(self):
		return self._tool_file_name

class MissingBuildFileError(BuildError):
	"""Raised when we can't build a project because one or more of its build
	files are missing or unreadable.
	"""
	def __init__(self, os_error):
		assert isinstance(os_error, OSError)
		if hasattr(os_error, 'filename'):
			self._filename = os_error.filename
		else:
			self._filename = None
		self._message = os_error.strerror
	
	def __str__(self):
		if self._filename is None:
			return self._message
		else:
			return "%s: %s" % (self._filename, self._message)

def build(base_path, build_info, rebuild):
	# input is a build_info tuple (as produced by create_build_info.py) and the
	# value of BASE from the same build_info file. If 'rebuild' is true, then
	# we will build from scratch (e.g. for finding warnings)
	# return (success : bool, errors : int, warnings : int, build_log : str)
	# raises a MissingDependencyError() exception if relevant.
	id_, config, path, extra = build_info
	
	assert isinstance(id_, str)
	assert isinstance(config, dict)
	assert isinstance(path, list)
	
	if not 'tool' in config:
		raise ValueError("Configuration doesn't specify build tool")
	
	if config['tool'] == 'make':
		return build_make(base_path, config, path, extra, rebuild)
	elif config['tool'] == 'msvs2005':
		return build_msvs(base_path, config, path, extra, rebuild, '2005')
	elif config['tool'] == 'msvs2008':
		return build_msvs(base_path, config, path, extra, rebuild, '2008')
	elif config['tool'] == 'msvs2010':
		return build_msvs(base_path, config, path, extra, rebuild, '2010')
	elif config['tool'] == 'msvs2012':
		return build_msvs(base_path, config, path, extra, rebuild, '2012')
	else:
		raise ValueError("Unknown build tool %r" % config['tool'])

def _make_expand_step(s, env):
	STATE_NORMAL = 0
	STATE_READ_DOLLAR = 1
	STATE_VARIABLE_NAME = 2
	
	
	ret = ''
	tail = '' # What we need to append to the returned string if our input suddenly ends
	var = None
	state = STATE_NORMAL
	name_terminator = None
	for c in s:
		if state == STATE_NORMAL:
			if c == '$':
				state = STATE_READ_DOLLAR
				tail = c
			else:
				ret += c
				tail = ''
		elif state == STATE_READ_DOLLAR:
			if c == '$':
				ret += '$'
				tail = ''
				state = STATE_NORMAL
			elif c in ['(', '{']:
				state = STATE_VARIABLE_NAME
				name_terminator = {'(': ')', '{': '}'}[c]
				var = ''
				tail += c
			else:
				# This is a hack, theoretically, it should treat the next letter as a variable
				# name (just a single letter), and do a substitution. 
				ret += '$' + c
				state = STATE_NORMAL
				tail = ''
		elif state == STATE_VARIABLE_NAME:
			if c == name_terminator:
				if var in env:
					ret += env[var]
				else:
					# Empty string if not found
					ret += ''
				var = None
				name_terminator = None
				state = STATE_NORMAL
				tail = ''
			else:
				var += c
				tail += c
	
	return ret + tail

def _make_expand(s):
	# Expands environment variables like make would do
	env = dict(os.environ)

	# These are the default values for variables as documented in the Make manual
	defaults = {'AR': 'ar',
	            'AS': 'as',
	            'CC': 'cc',
	            'CXX': 'g++',
	            'CPP': '$(CC) -E',
	            'FC': 'f77',
	            'M2C': 'm2c',
	            'PC': 'pc',
	            'CO': 'co',
	            'GET': 'get',
	            'LEX': 'lex',
	            'YACC': 'yacc',
	            'LINT': 'lint',
	            'MAKEINFO': 'makeinfo',
	            'TEX': 'tex',
	            'TEXI2DVI': 'texi2dvi',
	            'WEAVE': 'weave',
	            'CWEAVE': 'cweave',
	            'TANGLE': 'tangle',
	            'CTANGLE': 'ctangle',
	            'RM': 'rm -f'}
	
	for var in defaults:
		if not var in env:
			env[var] = defaults[var]
	
	for i in range(10):
		new_text = _make_expand_step(s, env)
		if s == new_text:
			return s
		s = new_text

	raise ValueError("Variable nesting too deep")

def _make_read_stderr_stats(stderr, toolchain):
	lines = stderr.split('\n')
	
	error_rexp = re.compile(r".*(?:(?:error)|(?:fatal))", re.IGNORECASE)
	warning_rexp = re.compile(r".*warn", re.IGNORECASE)
	
	errors = 0
	warnings = 0
	
	for line in lines:
		if error_rexp.match(line):
			errors += 1
		elif warning_rexp.match(line):
			warnings += 1
	
	return (errors, warnings)

def build_make(base_path, config, path, extra, rebuild):
	# extra contains the binaries we need in order to actually build this
	file_deps, env_deps = extra
	for dep in file_deps:
		expand_dep = _make_expand(dep)
		dep_name = shlex.split(expand_dep)[0]
		if which(dep_name) is None:
			raise MissingDependencyError(dep, expand_dep)
	
	env = os.environ
	for this_env in env_deps:
		if not this_env in env:
			raise MissingDependencyError("$(%s)" % this_env, None)
	
	
	# Change to the directory, run make, capture and parse stderr
	args = ['make', path[-1]]
	if rebuild:
		args.append('--always-make')
	try:
		p = subprocess.Popen(args,
		                     stdout=subprocess.PIPE,
		                     stderr=subprocess.PIPE,
		                     cwd=os.path.join(base_path, *path[0:-1]))
		(stdout, stderr) = p.communicate()
		
		success = (p.returncode == 0)
		
		errors, warnings = _make_read_stderr_stats(stderr, config['toolchain'])
		
		return (success, errors, warnings, stderr)
	except OSError, e:
		return (False, 1, 0, str(e))

def get_vs_path(version):
	if version in ['2005', '2008', '2010', '2012']:
		varname = {'2005': 'VS80COMNTOOLS',
		           '2008': 'VS90COMNTOOLS',
		           '2010': 'VS100COMNTOOLS',
		           '2012': 'VS110COMNTOOLS'}[version]

		if not varname in os.environ:
			return None
		
		common_tools = os.environ[varname]
		
		path = os.path.join(common_tools, '..', 'IDE', 'devenv.exe')
		if os.path.exists(path):
			return path
		return None
	else:
		return None

def build_msvs(base_path, config, path, extra, rebuild, vs_version):
	assert isinstance(base_path, str)
	assert isinstance(config, dict)
	assert isinstance(path, list)
	assert isinstance(extra, tuple)
	assert isinstance(rebuild, bool)
	assert isinstance(vs_version, str)
	
	project_name, vs_config_name = extra
	assert isinstance(project_name, str)
	assert isinstance(vs_config_name, str)
	
	devenv = get_vs_path(vs_version)
	if devenv is None:
		raise MissingDependencyError("Visual Studio %s not found" % (vs_version), 'devenv.exe')
	
	args = [devenv]
	project_path = [base_path] + path[0:-3] + [project_name]
	args.append(os.path.join(*project_path))
	if rebuild:
		args.append('/Rebuild')
	else:
		args.append('/Build')
	args.append(vs_config_name)
	
	output_log = tempfile.NamedTemporaryFile(delete=False)
	args.append('/Out')
	log_name = output_log.name
	output_log.close()
	try:
		args.append(output_log.name)
	
		proc = subprocess.Popen(args)
		proc.communicate()

		output_log = open(log_name, "r")
		output_log_str = output_log.read()
		output_log.close()
	finally:
		os.remove(log_name)
	

	compile_errors, link_errors, warnings = _vs_read_output_log_stats(output_log_str)
	
	success = (proc.returncode == 0)
	
	return (success, compile_errors + link_errors, warnings, output_log_str)

class ParseError(Exception): pass

def _vs_read_output_log_stats(log):
	lines = log.split('\n')
	
	compile_error_rexp = re.compile(r"[0-9]+>(.*)\(([0-9]+)\) : (?:fatal )?error.*: (.*)")
	link_error_rexp = re.compile(r"[0-9]+>(.*) : (?:fatal )?error.*: (.*)")
	warning_rexp = re.compile(r"[0-9]+>(.*)\(([0-9]+)\) : warning.*: (.*)")
	
	compile_errors = 0
	link_errors = 0
	warnings = 0
	
	for line in lines:
		if compile_error_rexp.match(line):
			compile_errors += 1
		if link_error_rexp.match(line):
			link_errors += 1
		elif warning_rexp.match(line):
			warnings += 1
	
	return (compile_errors, link_errors, warnings)

def main(args):
	parser = optparse.OptionParser(__doc__)
	parser.add_option("-r", "--rebuild", dest="rebuild",
	                  default=False,
	                  action="store_true",
	                  help="Rebuild all objects from source")
	parser.add_option("-v", "--verbose", dest="verbose",
	                  default=False,
	                  action="store_true",
	                  help="Print out commands being run")
	
	(options, args) = parser.parse_args(args=args)
	
	if len(args) != 3:
		parser.error("You must specify a build info file and an ID")
	
	build_info_module = imp.load_source('build_info', args[1])
	id_ = args[2]
	rebuild = options.rebuild
	
	found_id = False
	for info in build_info_module.build_info:
		(this_id, configuration, filename, extra) = info
		if this_id == id_:
			found_id = True
			try:
				success, errors, warnings, log = build(build_info_module.BASE, info, rebuild)
				if errors > 0 or warnings > 0 or not success:
					print log
				print "%d errors" % (errors)
				print "%d warnings" % (warnings)
				if success:
					ret = 0
					print "Binary at: %s" % (os.path.join(build_info_module.BASE, *filename))
				else:
					ret = 1

			except MissingDependencyError, e:
				if e.get_tool_file_name() is None:
					sys.stderr.write("Missing Dependency Tool: %r\n" % (e.get_tool_name()))
				else:
					sys.stderr.write("Missing Dependency Tool: %r (file %r)\n" % (e.get_tool_name(), e.get_tool_file_name()))

				ret = 2
	
	if not found_id:
		ret = 2
		sys.stderr.write("No such ID (%r) in this build file. Example ID is %r\n" % (id_, build_info_module.build_info[0][0]))
	
	
	return ret

if __name__ == '__main__':
	sys.exit(main(sys.argv))

